using System;

namespace console_1
{
    class Program
    {
        static void Main()
        {
            Console.Write("Введите размер матрицы: ");
            if (!int.TryParse(Console.ReadLine(), out int n) || n <= 0)
            {
                Console.WriteLine("Неверный размер.");
                return;
            }

            int[,] matrix = new int[n, n];

            // Заполнение матрицы значениями 1..N*N (исходная, хотя мы потом её перестраиваем)
            int value = 1;
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    matrix[i, j] = value++;

            Console.WriteLine("\nИсходная матрица:\n");
            PrintMatrix(matrix);

            Console.WriteLine("\nВыберите угол, с которого начнётся спираль:");
            Console.WriteLine("1 — Верхний левый");
            Console.WriteLine("2 — Верхний правый");
            Console.WriteLine("3 — Нижний правый");
            Console.WriteLine("4 — Нижний левый");
            if (!int.TryParse(Console.ReadLine(), out int corner) || corner < 1 || corner > 4)
            {
                Console.WriteLine("Неправильный выбор угла.");
                return;
            }

            Console.WriteLine("\nВыберите направление заполнения:");
            Console.WriteLine("1 — По часовой стрелке");
            Console.WriteLine("2 — Против часовой стрелки");
            if (!int.TryParse(Console.ReadLine(), out int direction) || (direction != 1 && direction != 2))
            {
                Console.WriteLine("Неправильный выбор направления.");
                return;
            }

            int[,] spiral = BuildSpiral(matrix, corner, direction);

            Console.WriteLine("\nСпиральная матрица:\n");
            PrintMatrix(spiral);
        }

        // Построение спирали: надёжный симулятивный метод (движение + поворот при необходимости)
        static int[,] BuildSpiral(int[,] original, int startCorner, int direction)
        {
            int n = original.GetLength(0);
            int[,] result = new int[n, n];

            // Плоский массив значений, которые нужно разместить в спирали
            int[] flat = new int[n * n];
            int idxFlat = 0;
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    flat[idxFlat++] = original[i, j];

            // visited для контроля границ/занятых ячеек
            bool[,] visited = new bool[n, n];

            // начальная позиция в зависимости от выбранного угла
            int r = 0, c = 0;
            switch (startCorner)
            {
                case 1: // верхний левый
                    r = 0; c = 0;
                    break;
                case 2: // верхний правый
                    r = 0; c = n - 1;
                    break;
                case 3: // нижний правый
                    r = n - 1; c = n - 1;
                    break;
                case 4: // нижний левый
                    r = n - 1; c = 0;
                    break;
            }

            // начальная дирекция (dr, dc)
            // для по часовой (CW) нач.направления:
            // UL -> →, UR -> ↓, BR -> ←, BL -> ↑
            // для против часовой (CCW) нач.направления:
            // UL -> ↓, UR -> ←, BR -> ↑, BL -> →
            int dr = 0, dc = 0;
            if (direction == 1) // CW
            {
                switch (startCorner)
                {
                    case 1: dr = 0; dc = 1; break;  // →
                    case 2: dr = 1; dc = 0; break;  // ↓
                    case 3: dr = 0; dc = -1; break; // ←
                    case 4: dr = -1; dc = 0; break; // ↑
                }
            }
            else // CCW
            {
                switch (startCorner)
                {
                    case 1: dr = 1; dc = 0; break;  // ↓
                    case 2: dr = 0; dc = -1; break; // ←
                    case 3: dr = -1; dc = 0; break; // ↑
                    case 4: dr = 0; dc = 1; break;  // →
                }
            }

            // функции поворота:
            // для CW поворот "вправо": (dr,dc) -> (dc, -dr)
            // для CCW поворот "влево":  (dr,dc) -> (-dc, dr)
            Func<(int, int), (int, int)> turn = direction == 1
                ? new Func<(int, int), (int, int)>(d => (d.Item2, -d.Item1))   // вправо
                : new Func<(int, int), (int, int)>(d => (-d.Item2, d.Item1));  // влево

            int fillIdx = 0;
            for (int steps = 0; steps < n * n; steps++)
            {
                result[r, c] = flat[fillIdx++];
                visited[r, c] = true;

                int nr = r + dr;
                int nc = c + dc;

                // если следующий шаг выходит за границы или уже занят — поворачиваем
                if (nr < 0 || nr >= n || nc < 0 || nc >= n || visited[nr, nc])
                {
                    (dr, dc) = turn((dr, dc));
                    nr = r + dr;
                    nc = c + dc;
                }

                r = nr;
                c = nc;
            }

            return result;
        }

        static void PrintMatrix(int[,] m)
        {
            int n = m.GetLength(0);
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                    Console.Write(m[i, j].ToString().PadLeft(3) + " ");
                Console.WriteLine();
            }
        }
    }
}
