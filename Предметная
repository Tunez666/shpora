Предметной областью данного проекта является разработка социальной сети с поддержкой медиа-контента, предназначенной для общения пользователей, публикации информации и формирования социальных связей.

Социальная сеть представляет собой информационную систему, в которой основным объектом является пользователь, обладающий уникальной учётной записью. Каждый пользователь имеет персональные данные, включая имя, адрес электронной почты, пароль, статус, биографию и аватар. Пользователь может управлять своим профилем, публиковать записи и взаимодействовать с другими участниками системы.

В системе реализован механизм публикации постов, содержащих текстовую информацию и до трёх медиафайлов. Каждый пост связан с конкретным пользователем и может быть прокомментирован другими пользователями. Комментарии также хранятся в системе как отдельные сущности и связаны как с постом, так и с автором комментария.

Для оценки активности и популярности контента предусмотрена система лайков, которая позволяет пользователям выражать отношение к постам и комментариям. Лайки хранятся отдельно для постов и комментариев, что обеспечивает корректный учёт взаимодействий.
В социальной сети реализован функционал добавления пользователей в друзья. Для этого используется система запросов в друзья, которая включает отправку, принятие и отклонение запросов. Состояние запроса определяется статусом, хранящимся в отдельной таблице статусов. После принятия запроса между пользователями формируется запись о дружбе. Таким образом обеспечивается контроль социальных связей и их текущего состояния.

Дополнительно в системе реализована возможность создания групп по интересам. Группа имеет название, описание, аватар и создателя. Пользователи могут вступать в группы, при этом информация об участниках групп хранится в отдельной таблице, что позволяет учитывать состав групп и управлять членством.

Все данные системы хранятся в реляционной базе данных, структура которой спроектирована с учётом принципов нормализации и приведена к третьей нормальной форме. Это обеспечивает целостность данных, минимизацию избыточности и возможность дальнейшего расширения функционала социальной сети.


Вывод о проделанной работе

В ходе выполнения работы была проведена разработка предметной области социальной сети с медиаконтентом и построена соответствующая ей структура базы данных.

На этапе анализа предметной области были выделены ключевые сущности системы: пользователи, посты, комментарии, лайки, друзья, запросы в друзья, группы и участники групп. Каждая сущность получила своё назначение, учитывающее функциональные требования социальной сети, включая возможность публикации медиа-контента, взаимодействия пользователей через лайки и комментарии, создание дружеских связей и организацию сообществ по интересам.

На основе предметной области была спроектирована реляционная база данных. Структура базы приведена к третьей нормальной форме (3НФ), что обеспечивает минимизацию избыточности данных, целостность информации и удобство её обработки. Для каждой сущности определены таблицы с уникальными идентификаторами, связями между таблицами через внешние ключи, а также ограничениями целостности.

Для наглядного представления и дальнейшего использования в проекте были составлены таблицы описаний сущностей, включающие название полей, тип данных, ограничения и краткое описание назначения каждого поля. Это позволило чётко зафиксировать структуру базы данных и использовать её как основу для реализации функционала социальной сети в среде разработки.

В результате выполненной работы получена полноценная модель данных, которая отражает все основные процессы и взаимодействия внутри социальной сети, обеспечивает поддержку медиаконтента и социальных функций, а также готова для дальнейшей интеграции с серверной логикой и пользовательским интерфейсом.


-- Примеры данных для социальной сети

USE 22019_social;

-- Таблица users
INSERT INTO users (name, password, email, number_p, status, bio, ava) VALUES
('Алексей', 'pass123', 'aleksey@mail.com', 2, 'online', 'Люблю фотографии и путешествия', 'ava1.jpg'),
('Мария', 'masha456', 'maria@mail.com', 1, 'offline', 'Читаю книги и смотрю фильмы', 'ava2.png'),
('Иван', 'ivan789', 'ivan@mail.com', 3, 'online', 'Фанат спорта и технологий', 'ava3.jpg'),
('Ольга', 'olga321', 'olga@mail.com', 0, 'away', 'Люблю готовить и рисовать', 'ava4.png'),
('Дмитрий', 'dmitry654', 'dmitry@mail.com', 4, 'online', 'Разрабатываю приложения', 'ava5.jpg');

-- Таблица req_statuses
INSERT INTO req_statuses (title) VALUES
('pending'),
('accepted'),
('rejected'),
('blocked'),
('canceled');

-- Таблица posts
INSERT INTO posts (id_u, main_t, media_one, media_two, media_three) VALUES
(1, 'Моя первая публикация!', 'photo1.jpg', NULL, NULL),
(2, 'Смотрите новое видео', 'video1.mp4', NULL, NULL),
(3, 'Фото с прогулки', 'photo2.jpg', 'photo3.jpg', NULL),
(4, 'Вкусный рецепт', NULL, NULL, NULL),
(5, 'Мой новый проект', 'screenshot1.png', 'screenshot2.png', 'diagram1.png');

-- Таблица comments_p
INSERT INTO comments_p (id_p, id_u, main_t) VALUES
(1, 2, 'Отличная публикация!'),
(1, 3, 'Супер!'),
(2, 1, 'Смотрел, классно!'),
(3, 5, 'Красивые фотографии'),
(4, 2, 'Обязательно попробую рецепт');

-- Таблица likes_p
INSERT INTO likes_p (id_p, main_t) VALUES
(1, 'like'),
(1, 'like'),
(2, 'like'),
(3, 'like'),
(5, 'like');

-- Таблица likes_c
INSERT INTO likes_c (id_c) VALUES
(1),
(2),
(3),
(4),
(5);

-- Таблица friends
INSERT INTO friends (id_friend_one, id_friend_two) VALUES
(1, 2),
(1, 3),
(2, 3),
(4, 5),
(3, 5);

-- Таблица friends_requests
INSERT INTO friends_requests (id_friend_one, id_friend_two, id_s) VALUES
(2, 4, 1),
(3, 4, 1),
(5, 1, 1),
(4, 2, 2),
(1, 5, 3);

-- Таблица groups
INSERT INTO groups (name, creater, bio, ava) VALUES
('Фотография', 1, 'Группа для любителей фото', 'grp1.png'),
('Кулинария', 2, 'Рецепты и советы', 'grp2.jpg'),
('Спорт', 3, 'Общение о тренировках', 'grp3.png'),
('Программирование', 5, 'Все о коде и проектах', 'grp4.png'),
('Книги', 4, 'Чтение и обсуждения', 'grp5.jpg');



-- Таблица members_groups
INSERT INTO members_groups (id_m, id_g) VALUES
(1, 1),
(2, 1),
(3, 3),
(4, 2),
(5, 4);

У меня получилась такая бд. Подстрой пол нее пожалуйста: -- Создание базы данных
CREATE DATABASE IF NOT EXISTS 22019_social;
USE 22019_social;

-- Таблица пользователей
CREATE TABLE users (
    id_u INT(11) NOT NULL AUTO_INCREMENT,
    name VARCHAR(45) NOT NULL,
    password VARCHAR(45) NOT NULL,
    email VARCHAR(45) NOT NULL,
    number_p INT(11) DEFAULT 0,
    status TEXT,
    bio TEXT,
    ava VARCHAR(255),
    PRIMARY KEY (id_u)
);

-- Таблица статусов запросов
CREATE TABLE req_statuses (
    id_r INT(11) NOT NULL AUTO_INCREMENT,
    title VARCHAR(45) NOT NULL,
    PRIMARY KEY (id_r)
);

-- Таблица постов
CREATE TABLE posts (
    id_p INT(11) NOT NULL AUTO_INCREMENT,
    id_u INT(11) NOT NULL,
    main_t TEXT,
    media_one VARCHAR(255),
    media_two VARCHAR(255),
    media_three VARCHAR(255),
    PRIMARY KEY (id_p),
    FOREIGN KEY (id_u) REFERENCES users(id_u) ON DELETE CASCADE
);

-- Таблица комментариев к постам
CREATE TABLE comments_p (
    id_c INT(11) NOT NULL AUTO_INCREMENT,
    id_p INT(11) NOT NULL,
    id_u INT(11) NOT NULL,
    main_t TEXT,
    PRIMARY KEY (id_c),
    FOREIGN KEY (id_p) REFERENCES posts(id_p) ON DELETE CASCADE,
    FOREIGN KEY (id_u) REFERENCES users(id_u) ON DELETE CASCADE
);

-- Таблица лайков постов
CREATE TABLE likes_p (
    id_l INT(11) NOT NULL AUTO_INCREMENT,
    id_p INT(11) NOT NULL,
    main_t TEXT,
    PRIMARY KEY (id_l),
    FOREIGN KEY (id_p) REFERENCES posts(id_p) ON DELETE CASCADE
);

-- Таблица лайков комментариев
CREATE TABLE likes_c (
    id_lc INT(11) NOT NULL AUTO_INCREMENT,
    id_c INT(11) NOT NULL,
    PRIMARY KEY (id_lc),
    FOREIGN KEY (id_c) REFERENCES comments_p(id_c) ON DELETE CASCADE
);

-- Таблица друзей
CREATE TABLE friends (
    id_f INT(11) NOT NULL AUTO_INCREMENT,
    id_friend_one INT(11) NOT NULL,
    id_friend_two INT(11) NOT NULL,
    PRIMARY KEY (id_f),
    FOREIGN KEY (id_friend_one) REFERENCES users(id_u) ON DELETE CASCADE,
    FOREIGN KEY (id_friend_two) REFERENCES users(id_u) ON DELETE CASCADE
);

-- Таблица запросов в друзья
CREATE TABLE friends_requests (
    id_f_r INT(11) NOT NULL AUTO_INCREMENT,
    id_friend_one INT(11) NOT NULL,
    id_friend_two INT(11) NOT NULL,
    id_s INT(11) NOT NULL,
    PRIMARY KEY (id_f_r),
    FOREIGN KEY (id_friend_one) REFERENCES users(id_u) ON DELETE CASCADE,
    FOREIGN KEY (id_friend_two) REFERENCES users(id_u) ON DELETE CASCADE,
    FOREIGN KEY (id_s) REFERENCES req_statuses(id_r) ON DELETE CASCADE
);

-- Таблица групп
CREATE TABLE groups (
    id_g INT(11) NOT NULL AUTO_INCREMENT,
    name VARCHAR(45) NOT NULL,
    creater INT(11) NOT NULL,
    bio TEXT,
    ava VARCHAR(45),
    PRIMARY KEY (id_g),
    FOREIGN KEY (creater) REFERENCES users(id_u) ON DELETE CASCADE
);

-- Таблица участников групп
CREATE TABLE members_groups (
    id_mg INT(11) NOT NULL AUTO_INCREMENT,
    id_m INT(11) NOT NULL,
    id_g INT(11) NOT NULL,
    PRIMARY KEY (id_mg),
    FOREIGN KEY (id_m) REFERENCES users(id_u) ON DELETE CASCADE,
    FOREIGN KEY (id_g) REFERENCES groups(id_g) ON DELETE CASCADE
);



Задача 1.5 — Группировка с GROUP BY
Сгруппируйте данные по категориальному столбцу (например, category_id, city) и для каждой группы вычислите количество записей и максимальное значение числового столбца.
Часть 2
Задача 2.1 — JOIN двух таблиц
Сделайте запрос с объединением двух связанных таблиц (например, orders и users). Выведите определённые столбцы из обеих таблиц. Используйте INNER JOIN.
Задача 2.2 — LEFT JOIN с условием
Используйте LEFT JOIN для вывода всех записей из главной таблицы и связанных данных из второй таблицы. Добавьте условие, при котором часть связанных данных может отсутствовать (NULL).
Задача 2.3 — Вложенные запросы (SELECT в WHERE)
Напишите запрос, который использует результат подзапроса в условии WHERE (например, выбрать все товары, цена которых выше средней цены всех товаров).
Задача 2.4 — Операторы IN и BETWEEN
Выберите данные, где значение столбца находится в списке, полученном из подзапроса, или в диапазоне дат/чисел.
Задача 2.5 — CASE в SELECT
Используйте оператор CASE для категоризации данных прямо в запросе (например, разделите товары на категории «дешёвые», «средние», «дорогие» на основе цены).
Часть 3
Задача 3.1 — Многотабличный JOIN с агрегацией
Объедините три или более таблиц. Сгруппируйте результат и рассчитайте агрегированные показатели (например, общая выручка по каждому клиенту с указанием региона).
Задача 3.2 — Подзапросы в FROM и JOIN
Создайте запрос, где одна из присоединяемых таблиц является подзапросом с агрегацией или фильтрацией.
Задача 3.3 — Рекурсивный запрос или WITH (CTE)
Используйте выражение WITH для создания временного результата (CTE) и последующего обращения к нему в основном запросе. Пример: расчёт накопительного итога или иерархии.
Задача 3.4 — Оптимизация: анализ плана запроса
Выполните один из сложных запросов (например, из задачи 3.1) с включённым выводом плана выполнения (EXPLAIN или EXPLAIN ANALYZE). Предложите, как можно оптимизировать запрос (добавить индекс, изменить условие и т.д.).
Задача 3.5 — WINDOW-функции
Примените оконную функцию (ROW_NUMBER(), RANK(), SUM() OVER()) для ранжирования данных или расчёта скользящего среднего внутри групп.
Часть 4
Задача 4.1 — Комплексный аналитический запрос
Напишите единый запрос, который включает:
•	Не менее двух JOIN.
•	Фильтрацию по дате.
•	Группировку по одному или нескольким полям.
•	Оконную функцию или подзапрос.
•	Сортировку по агрегированному значению.
*Пример: «Топ-5 клиентов по сумме заказов за последний квартал с указанием доли их заказов от общего объёма».*
Задача 4.2 — Самостоятельное формулирование запроса
На основе вашей схемы БД самостоятельно сформулируйте и выполните нетривиальный запрос, который даёт ответ на гипотетический бизнес-вопрос (например, «В какие дни недели происходит наибольшее количество отмен заказов?»).


-- =============================================
-- SQL-запросы для анализа БД социальной сети
-- =============================================

USE 22019_social;

-- ЧАСТЬ 1
-- Задача 1.5 — GROUP BY + агрегатные функции
SELECT 
    id_u,
    COUNT(*) AS posts_count,
    MAX(id_p) AS max_post_id
FROM posts
GROUP BY id_u;

-- =============================================
-- ЧАСТЬ 2

-- Задача 2.1 — INNER JOIN двух таблиц
SELECT 
    u.name,
    p.main_t
FROM posts p
INNER JOIN users u ON p.id_u = u.id_u;

-- Задача 2.2 — LEFT JOIN с NULL
SELECT 
    u.name,
    p.main_t
FROM users u
LEFT JOIN posts p ON u.id_u = p.id_u;

-- Задача 2.3 — Подзапрос в WHERE
SELECT *
FROM posts
WHERE id_u IN (
    SELECT id_u
    FROM users
    WHERE number_p > (
        SELECT AVG(number_p) FROM users
    )
);

-- Задача 2.4 — IN и BETWEEN
SELECT *
FROM comments_p
WHERE id_p BETWEEN 1 AND 3;

SELECT *
FROM posts
WHERE id_u IN (
    SELECT id_u
    FROM users
    WHERE status = 'online'
);

-- Задача 2.5 — CASE в SELECT
SELECT 
    name,
    number_p,
    CASE
        WHEN number_p = 0 THEN 'Неактивный'
        WHEN number_p BETWEEN 1 AND 2 THEN 'Среднеактивный'
        ELSE 'Активный'
    END AS activity_level
FROM users;

-- =============================================
-- ЧАСТЬ 3

-- Задача 3.1 — Многотабличный JOIN с агрегацией
SELECT 
    u.name,
    COUNT(lp.id_l) AS likes_count
FROM users u
JOIN posts p ON u.id_u = p.id_u
LEFT JOIN likes_p lp ON p.id_p = lp.id_p
GROUP BY u.name;

-- Задача 3.2 — Подзапрос в FROM
SELECT 
    u.name,
    pc.posts_count
FROM users u
JOIN (
    SELECT id_u, COUNT(*) AS posts_count
    FROM posts
    GROUP BY id_u
) pc ON u.id_u = pc.id_u;

-- Задача 3.3 — WITH (CTE)
WITH post_stats AS (
    SELECT id_u, COUNT(*) AS cnt
    FROM posts
    GROUP BY id_u
)
SELECT u.name, ps.cnt
FROM post_stats ps
JOIN users u ON ps.id_u = u.id_u
WHERE ps.cnt > 2;

-- Задача 3.4 — EXPLAIN плана выполнения
EXPLAIN
SELECT 
    u.name,
    COUNT(lp.id_l)
FROM users u
JOIN posts p ON u.id_u = p.id_u
LEFT JOIN likes_p lp ON p.id_p = lp.id_p
GROUP BY u.name;

-- Задача 3.5 — WINDOW-функции
SELECT 
    name,
    number_p,
    RANK() OVER (ORDER BY number_p DESC) AS rating
FROM users;

-- =============================================
-- ЧАСТЬ 4

-- Задача 4.1 — Комплексный аналитический запрос
WITH likes_stat AS (
    SELECT 
        u.id_u,
        u.name,
        COUNT(lp.id_l) AS likes_count
    FROM users u
    JOIN posts p ON u.id_u = p.id_u
    LEFT JOIN likes_p lp ON p.id_p = lp.id_p
    GROUP BY u.id_u, u.name
)
SELECT *,
       RANK() OVER (ORDER BY likes_count DESC) AS place
FROM likes_stat
ORDER BY likes_count DESC
LIMIT 5;

-- Задача 4.2 — Бизнес-запрос
SELECT 
    g.name,
    COUNT(mg.id_m) AS members_count
FROM groups g
LEFT JOIN members_groups mg ON g.id_g = mg.id_g
GROUP BY g.name
ORDER BY members_count DESC;

