Предметной областью данного проекта является разработка социальной сети с поддержкой медиа-контента, предназначенной для общения пользователей, публикации информации и формирования социальных связей.

Социальная сеть представляет собой информационную систему, в которой основным объектом является пользователь, обладающий уникальной учётной записью. Каждый пользователь имеет персональные данные, включая имя, адрес электронной почты, пароль, статус, биографию и аватар. Пользователь может управлять своим профилем, публиковать записи и взаимодействовать с другими участниками системы.

В системе реализован механизм публикации постов, содержащих текстовую информацию и до трёх медиафайлов. Каждый пост связан с конкретным пользователем и может быть прокомментирован другими пользователями. Комментарии также хранятся в системе как отдельные сущности и связаны как с постом, так и с автором комментария.

Для оценки активности и популярности контента предусмотрена система лайков, которая позволяет пользователям выражать отношение к постам и комментариям. Лайки хранятся отдельно для постов и комментариев, что обеспечивает корректный учёт взаимодействий.
В социальной сети реализован функционал добавления пользователей в друзья. Для этого используется система запросов в друзья, которая включает отправку, принятие и отклонение запросов. Состояние запроса определяется статусом, хранящимся в отдельной таблице статусов. После принятия запроса между пользователями формируется запись о дружбе. Таким образом обеспечивается контроль социальных связей и их текущего состояния.

Дополнительно в системе реализована возможность создания групп по интересам. Группа имеет название, описание, аватар и создателя. Пользователи могут вступать в группы, при этом информация об участниках групп хранится в отдельной таблице, что позволяет учитывать состав групп и управлять членством.

Все данные системы хранятся в реляционной базе данных, структура которой спроектирована с учётом принципов нормализации и приведена к третьей нормальной форме. Это обеспечивает целостность данных, минимизацию избыточности и возможность дальнейшего расширения функционала социальной сети.


Вывод о проделанной работе

В ходе выполнения работы была проведена разработка предметной области социальной сети с медиаконтентом и построена соответствующая ей структура базы данных.

На этапе анализа предметной области были выделены ключевые сущности системы: пользователи, посты, комментарии, лайки, друзья, запросы в друзья, группы и участники групп. Каждая сущность получила своё назначение, учитывающее функциональные требования социальной сети, включая возможность публикации медиа-контента, взаимодействия пользователей через лайки и комментарии, создание дружеских связей и организацию сообществ по интересам.

На основе предметной области была спроектирована реляционная база данных. Структура базы приведена к третьей нормальной форме (3НФ), что обеспечивает минимизацию избыточности данных, целостность информации и удобство её обработки. Для каждой сущности определены таблицы с уникальными идентификаторами, связями между таблицами через внешние ключи, а также ограничениями целостности.

Для наглядного представления и дальнейшего использования в проекте были составлены таблицы описаний сущностей, включающие название полей, тип данных, ограничения и краткое описание назначения каждого поля. Это позволило чётко зафиксировать структуру базы данных и использовать её как основу для реализации функционала социальной сети в среде разработки.

В результате выполненной работы получена полноценная модель данных, которая отражает все основные процессы и взаимодействия внутри социальной сети, обеспечивает поддержку медиаконтента и социальных функций, а также готова для дальнейшей интеграции с серверной логикой и пользовательским интерфейсом.


-- Примеры данных для социальной сети

USE 22019_social;

-- Таблица users
INSERT INTO users (name, password, email, number_p, status, bio, ava) VALUES
('Алексей', 'pass123', 'aleksey@mail.com', 2, 'online', 'Люблю фотографии и путешествия', 'ava1.jpg'),
('Мария', 'masha456', 'maria@mail.com', 1, 'offline', 'Читаю книги и смотрю фильмы', 'ava2.png'),
('Иван', 'ivan789', 'ivan@mail.com', 3, 'online', 'Фанат спорта и технологий', 'ava3.jpg'),
('Ольга', 'olga321', 'olga@mail.com', 0, 'away', 'Люблю готовить и рисовать', 'ava4.png'),
('Дмитрий', 'dmitry654', 'dmitry@mail.com', 4, 'online', 'Разрабатываю приложения', 'ava5.jpg');

-- Таблица req_statuses
INSERT INTO req_statuses (title) VALUES
('pending'),
('accepted'),
('rejected'),
('blocked'),
('canceled');

-- Таблица posts
INSERT INTO posts (id_u, main_t, media_one, media_two, media_three) VALUES
(1, 'Моя первая публикация!', 'photo1.jpg', NULL, NULL),
(2, 'Смотрите новое видео', 'video1.mp4', NULL, NULL),
(3, 'Фото с прогулки', 'photo2.jpg', 'photo3.jpg', NULL),
(4, 'Вкусный рецепт', NULL, NULL, NULL),
(5, 'Мой новый проект', 'screenshot1.png', 'screenshot2.png', 'diagram1.png');

-- Таблица comments_p
INSERT INTO comments_p (id_p, id_u, main_t) VALUES
(1, 2, 'Отличная публикация!'),
(1, 3, 'Супер!'),
(2, 1, 'Смотрел, классно!'),
(3, 5, 'Красивые фотографии'),
(4, 2, 'Обязательно попробую рецепт');

-- Таблица likes_p
INSERT INTO likes_p (id_p, main_t) VALUES
(1, 'like'),
(1, 'like'),
(2, 'like'),
(3, 'like'),
(5, 'like');

-- Таблица likes_c
INSERT INTO likes_c (id_c) VALUES
(1),
(2),
(3),
(4),
(5);

-- Таблица friends
INSERT INTO friends (id_friend_one, id_friend_two) VALUES
(1, 2),
(1, 3),
(2, 3),
(4, 5),
(3, 5);

-- Таблица friends_requests
INSERT INTO friends_requests (id_friend_one, id_friend_two, id_s) VALUES
(2, 4, 1),
(3, 4, 1),
(5, 1, 1),
(4, 2, 2),
(1, 5, 3);

-- Таблица groups
INSERT INTO groups (name, creater, bio, ava) VALUES
('Фотография', 1, 'Группа для любителей фото', 'grp1.png'),
('Кулинария', 2, 'Рецепты и советы', 'grp2.jpg'),
('Спорт', 3, 'Общение о тренировках', 'grp3.png'),
('Программирование', 5, 'Все о коде и проектах', 'grp4.png'),
('Книги', 4, 'Чтение и обсуждения', 'grp5.jpg');



-- Таблица members_groups
INSERT INTO members_groups (id_m, id_g) VALUES
(1, 1),
(2, 1),
(3, 3),
(4, 2),
(5, 4);

У меня получилась такая бд. Подстрой пол нее пожалуйста: -- Создание базы данных
CREATE DATABASE IF NOT EXISTS 22019_social;
USE 22019_social;

-- Таблица пользователей
CREATE TABLE users (
    id_u INT(11) NOT NULL AUTO_INCREMENT,
    name VARCHAR(45) NOT NULL,
    password VARCHAR(45) NOT NULL,
    email VARCHAR(45) NOT NULL,
    number_p INT(11) DEFAULT 0,
    status TEXT,
    bio TEXT,
    ava VARCHAR(255),
    PRIMARY KEY (id_u)
);

-- Таблица статусов запросов
CREATE TABLE req_statuses (
    id_r INT(11) NOT NULL AUTO_INCREMENT,
    title VARCHAR(45) NOT NULL,
    PRIMARY KEY (id_r)
);

-- Таблица постов
CREATE TABLE posts (
    id_p INT(11) NOT NULL AUTO_INCREMENT,
    id_u INT(11) NOT NULL,
    main_t TEXT,
    media_one VARCHAR(255),
    media_two VARCHAR(255),
    media_three VARCHAR(255),
    PRIMARY KEY (id_p),
    FOREIGN KEY (id_u) REFERENCES users(id_u) ON DELETE CASCADE
);

-- Таблица комментариев к постам
CREATE TABLE comments_p (
    id_c INT(11) NOT NULL AUTO_INCREMENT,
    id_p INT(11) NOT NULL,
    id_u INT(11) NOT NULL,
    main_t TEXT,
    PRIMARY KEY (id_c),
    FOREIGN KEY (id_p) REFERENCES posts(id_p) ON DELETE CASCADE,
    FOREIGN KEY (id_u) REFERENCES users(id_u) ON DELETE CASCADE
);

-- Таблица лайков постов
CREATE TABLE likes_p (
    id_l INT(11) NOT NULL AUTO_INCREMENT,
    id_p INT(11) NOT NULL,
    main_t TEXT,
    PRIMARY KEY (id_l),
    FOREIGN KEY (id_p) REFERENCES posts(id_p) ON DELETE CASCADE
);

-- Таблица лайков комментариев
CREATE TABLE likes_c (
    id_lc INT(11) NOT NULL AUTO_INCREMENT,
    id_c INT(11) NOT NULL,
    PRIMARY KEY (id_lc),
    FOREIGN KEY (id_c) REFERENCES comments_p(id_c) ON DELETE CASCADE
);

-- Таблица друзей
CREATE TABLE friends (
    id_f INT(11) NOT NULL AUTO_INCREMENT,
    id_friend_one INT(11) NOT NULL,
    id_friend_two INT(11) NOT NULL,
    PRIMARY KEY (id_f),
    FOREIGN KEY (id_friend_one) REFERENCES users(id_u) ON DELETE CASCADE,
    FOREIGN KEY (id_friend_two) REFERENCES users(id_u) ON DELETE CASCADE
);

-- Таблица запросов в друзья
CREATE TABLE friends_requests (
    id_f_r INT(11) NOT NULL AUTO_INCREMENT,
    id_friend_one INT(11) NOT NULL,
    id_friend_two INT(11) NOT NULL,
    id_s INT(11) NOT NULL,
    PRIMARY KEY (id_f_r),
    FOREIGN KEY (id_friend_one) REFERENCES users(id_u) ON DELETE CASCADE,
    FOREIGN KEY (id_friend_two) REFERENCES users(id_u) ON DELETE CASCADE,
    FOREIGN KEY (id_s) REFERENCES req_statuses(id_r) ON DELETE CASCADE
);

-- Таблица групп
CREATE TABLE groups (
    id_g INT(11) NOT NULL AUTO_INCREMENT,
    name VARCHAR(45) NOT NULL,
    creater INT(11) NOT NULL,
    bio TEXT,
    ava VARCHAR(45),
    PRIMARY KEY (id_g),
    FOREIGN KEY (creater) REFERENCES users(id_u) ON DELETE CASCADE
);

-- Таблица участников групп
CREATE TABLE members_groups (
    id_mg INT(11) NOT NULL AUTO_INCREMENT,
    id_m INT(11) NOT NULL,
    id_g INT(11) NOT NULL,
    PRIMARY KEY (id_mg),
    FOREIGN KEY (id_m) REFERENCES users(id_u) ON DELETE CASCADE,
    FOREIGN KEY (id_g) REFERENCES groups(id_g) ON DELETE CASCADE
);



Задача 1.5 — Группировка с GROUP BY
Сгруппируйте данные по категориальному столбцу (например, category_id, city) и для каждой группы вычислите количество записей и максимальное значение числового столбца.
Часть 2
Задача 2.1 — JOIN двух таблиц
Сделайте запрос с объединением двух связанных таблиц (например, orders и users). Выведите определённые столбцы из обеих таблиц. Используйте INNER JOIN.
Задача 2.2 — LEFT JOIN с условием
Используйте LEFT JOIN для вывода всех записей из главной таблицы и связанных данных из второй таблицы. Добавьте условие, при котором часть связанных данных может отсутствовать (NULL).
Задача 2.3 — Вложенные запросы (SELECT в WHERE)
Напишите запрос, который использует результат подзапроса в условии WHERE (например, выбрать все товары, цена которых выше средней цены всех товаров).
Задача 2.4 — Операторы IN и BETWEEN
Выберите данные, где значение столбца находится в списке, полученном из подзапроса, или в диапазоне дат/чисел.
Задача 2.5 — CASE в SELECT
Используйте оператор CASE для категоризации данных прямо в запросе (например, разделите товары на категории «дешёвые», «средние», «дорогие» на основе цены).
Часть 3
Задача 3.1 — Многотабличный JOIN с агрегацией
Объедините три или более таблиц. Сгруппируйте результат и рассчитайте агрегированные показатели (например, общая выручка по каждому клиенту с указанием региона).
Задача 3.2 — Подзапросы в FROM и JOIN
Создайте запрос, где одна из присоединяемых таблиц является подзапросом с агрегацией или фильтрацией.
Задача 3.3 — Рекурсивный запрос или WITH (CTE)
Используйте выражение WITH для создания временного результата (CTE) и последующего обращения к нему в основном запросе. Пример: расчёт накопительного итога или иерархии.
Задача 3.4 — Оптимизация: анализ плана запроса
Выполните один из сложных запросов (например, из задачи 3.1) с включённым выводом плана выполнения (EXPLAIN или EXPLAIN ANALYZE). Предложите, как можно оптимизировать запрос (добавить индекс, изменить условие и т.д.).
Задача 3.5 — WINDOW-функции
Примените оконную функцию (ROW_NUMBER(), RANK(), SUM() OVER()) для ранжирования данных или расчёта скользящего среднего внутри групп.
Часть 4
Задача 4.1 — Комплексный аналитический запрос
Напишите единый запрос, который включает:
•	Не менее двух JOIN.
•	Фильтрацию по дате.
•	Группировку по одному или нескольким полям.
•	Оконную функцию или подзапрос.
•	Сортировку по агрегированному значению.
*Пример: «Топ-5 клиентов по сумме заказов за последний квартал с указанием доли их заказов от общего объёма».*
Задача 4.2 — Самостоятельное формулирование запроса
На основе вашей схемы БД самостоятельно сформулируйте и выполните нетривиальный запрос, который даёт ответ на гипотетический бизнес-вопрос (например, «В какие дни недели происходит наибольшее количество отмен заказов?»).


-- =============================================
-- SQL-запросы для анализа БД социальной сети
-- =============================================

USE 22019_social;

-- ЧАСТЬ 1
-- Задача 1.5 — GROUP BY + агрегатные функции
SELECT 
    id_u,
    COUNT(*) AS posts_count,
    MAX(id_p) AS max_post_id
FROM posts
GROUP BY id_u;

-- =============================================
-- ЧАСТЬ 2

-- Задача 2.1 — INNER JOIN двух таблиц
SELECT 
    u.name,
    p.main_t
FROM posts p
INNER JOIN users u ON p.id_u = u.id_u;

-- Задача 2.2 — LEFT JOIN с NULL
SELECT 
    u.name,
    p.main_t
FROM users u
LEFT JOIN posts p ON u.id_u = p.id_u;

-- Задача 2.3 — Подзапрос в WHERE
SELECT *
FROM posts
WHERE id_u IN (
    SELECT id_u
    FROM users
    WHERE number_p > (
        SELECT AVG(number_p) FROM users
    )
);

-- Задача 2.4 — IN и BETWEEN
SELECT *
FROM comments_p
WHERE id_p BETWEEN 1 AND 3;

SELECT *
FROM posts
WHERE id_u IN (
    SELECT id_u
    FROM users
    WHERE status = 'online'
);

-- Задача 2.5 — CASE в SELECT
SELECT 
    name,
    number_p,
    CASE
        WHEN number_p = 0 THEN 'Неактивный'
        WHEN number_p BETWEEN 1 AND 2 THEN 'Среднеактивный'
        ELSE 'Активный'
    END AS activity_level
FROM users;

-- =============================================
-- ЧАСТЬ 3

-- Задача 3.1 — Многотабличный JOIN с агрегацией
SELECT 
    u.name,
    COUNT(lp.id_l) AS likes_count
FROM users u
JOIN posts p ON u.id_u = p.id_u
LEFT JOIN likes_p lp ON p.id_p = lp.id_p
GROUP BY u.name;

-- Задача 3.2 — Подзапрос в FROM
SELECT 
    u.name,
    pc.posts_count
FROM users u
JOIN (
    SELECT id_u, COUNT(*) AS posts_count
    FROM posts
    GROUP BY id_u
) pc ON u.id_u = pc.id_u;

-- Задача 3.3 — WITH (CTE)
WITH post_stats AS (
    SELECT id_u, COUNT(*) AS cnt
    FROM posts
    GROUP BY id_u
)
SELECT u.name, ps.cnt
FROM post_stats ps
JOIN users u ON ps.id_u = u.id_u
WHERE ps.cnt > 2;

-- Задача 3.4 — EXPLAIN плана выполнения
EXPLAIN
SELECT 
    u.name,
    COUNT(lp.id_l)
FROM users u
JOIN posts p ON u.id_u = p.id_u
LEFT JOIN likes_p lp ON p.id_p = lp.id_p
GROUP BY u.name;

-- Задача 3.5 — WINDOW-функции
SELECT 
    name,
    number_p,
    RANK() OVER (ORDER BY number_p DESC) AS rating
FROM users;

-- =============================================
-- ЧАСТЬ 4

-- Задача 4.1 — Комплексный аналитический запрос
WITH likes_stat AS (
    SELECT 
        u.id_u,
        u.name,
        COUNT(lp.id_l) AS likes_count
    FROM users u
    JOIN posts p ON u.id_u = p.id_u
    LEFT JOIN likes_p lp ON p.id_p = lp.id_p
    GROUP BY u.id_u, u.name
)
SELECT *,
       RANK() OVER (ORDER BY likes_count DESC) AS place
FROM likes_stat
ORDER BY likes_count DESC
LIMIT 5;

-- Задача 4.2 — Бизнес-запрос
SELECT 
    g.name,
    COUNT(mg.id_m) AS members_count
FROM groups g
LEFT JOIN members_groups mg ON g.id_g = mg.id_g
GROUP BY g.name
ORDER BY members_count DESC;




































Часть 1
Задача 1.1 — Простая процедура без параметров
Создайте хранимую процедуру, которая выводит список последних 10 записей из любой таблицы вашей БД. Процедура должна возвращать набор данных (SELECT). Вызовите процедуру и зафиксируйте результат.
Задача 1.2 — Процедура с входными параметрами
Создайте процедуру, которая принимает один входной параметр (например, category_id) и возвращает все записи из таблицы, соответствующие этому значению. Добавьте сортировку по второму столбцу.
Задача 1.3 — Процедура с выходным параметром
Напишите процедуру, которая принимает входной параметр (например, user_id) и возвращает через выходной параметр (OUT или INOUT) вычисленное значение (например, общую сумму всех заказов пользователя). Продемонстрируйте вызов с получением выходного значения.
Задача 1.4 — Процедура с несколькими параметрами
Создайте процедуру с тремя входными параметрами: два для фильтрации диапазона (date_from, date_to), третий — для дополнительного условия (status). Процедура должна возвращать отфильтрованный набор данных.
Задача 1.5 — Процедура с использованием переменных
Внутри процедуры объявите локальные переменные, присвойте им значения через SELECT ... INTO, выполните с ними арифметическую или строковую операцию и верните результат как единую строку (например, «Сумма: X, Количество: Y»).
Часть 2
Задача 2.1 — Процедура с условной логикой (IF / CASE)
Создайте процедуру, которая принимает числовой параметр (например, сумму заказа) и с помощью условных конструкций возвращает текстовый комментарий: «малый заказ», «средний заказ», «крупный заказ».
Задача 2.2 — Процедура с циклом
Напишите процедуру, которая с помощью цикла (LOOP, WHILE или курсора) формирует строку, содержащую последовательность чисел или идентификаторов, удовлетворяющих условию (например, все чётные id в диапазоне от 1 до N). Возвратите сформированную строку.
Задача 2.3 — Процедура с транзакцией
Создайте процедуру, которая выполняет несколько связанных INSERT/UPDATE операций в рамках одной транзакции. В случае ошибки любого из действий должен выполниться ROLLBACK, при успехе — COMMIT. Продемонстрируйте оба сценария.
Задача 2.4 — Процедура с обработкой исключений
Напишите процедуру, которая включает блок обработки ошибок (EXCEPTION или TRY...CATCH). Обработайте как минимум две конкретные ошибки (например, деление на ноль, нарушение уникальности) и предусмотрите возврат пользовательского сообщения об ошибке.
Задача 2.5 — Процедура, вызывающая другую процедуру
Создайте две процедуры: основную и вспомогательную. Вспомогательная процедура выполняет расчёт (например, вычисляет скидку). Основная процедура вызывает вспомогательную и использует её результат в своей логике.
Часть 3
Задача 3.1 — Процедура с динамическим SQL
Создайте процедуру, которая строит и выполняет динамический SQL-запрос на основе входных параметров (например, имя таблицы, имя столбца для сортировки). Обеспечьте защиту от SQL-инъекций (используйте параметризацию).
Задача 3.2 — Процедура для массовой обработки через курсор
Напишите процедуру, которая объявляет курсор для выборки набора записей, в цикле обрабатывает каждую запись (например, обновляет или вычисляет производное значение) и фиксирует изменения. Сравните производительность с единым UPDATE.
Задача 3.3 — Процедура с возвратом таблицы
Создайте процедуру, которая возвращает набор данных сложной структуры (результат JOIN нескольких таблиц с агрегацией). Обеспечьте возможность фильтрации через входные параметры.
Задача 3.4 — Процедура-обёртка для сложной бизнес-логики
Спроектируйте процедуру, которая инкапсулирует многошаговую бизнес-логику: проверка условий, выбор данных, модификация нескольких таблиц, логирование действий в отдельную таблицу аудита. Используйте транзакцию.
Задача 3.5 — Рекурсивная хранимая процедура (или с использованием CTE)
Реализуйте процедуру, которая с помощью рекурсии или рекурсивного CTE обходит иерархические данные (например, древовидную структуру категорий). Возвратите путь от корневого элемента до указанного в параметре.
Часть 4
Задача 4.1 — Анализ производительности процедуры
Выберите одну из сложных процедур (например, из Части 3) и проанализируйте её план выполнения. Предложите изменения для оптимизации (добавление индексов, изменение логики, отказ от курсора в пользу set-based операций).
Задача 4.2 — Написание процедуры по техническому заданию
Самостоятельно сформулируйте ТЗ для процедуры в предметной области вашей БД и реализуйте её. Пример ТЗ: «Процедура должна архивировать (перемещать в таблицу archive) все записи старше N лет, предварительно рассчитав для каждой записи итоговую сумму по связанным таблицам и записав её в поле total_amount архива».









USE 22019_social;
DELIMITER $$

/* ====================
   ПРОЦЕДУРЫ ДЛЯ 22019_social
   ==================== */

/* 1.1 Последние 10 постов */
CREATE PROCEDURE sp_last_10_posts()
BEGIN
    SELECT *
    FROM posts
    ORDER BY id_p DESC
    LIMIT 10;
END$$

/* 1.2 Посты конкретного пользователя */
CREATE PROCEDURE sp_posts_by_user(IN p_user_id INT)
BEGIN
    SELECT *
    FROM posts
    WHERE id_u = p_user_id
    ORDER BY id_p DESC;
END$$

/* 1.3 Количество постов пользователя */
CREATE PROCEDURE sp_user_posts_count(IN p_user_id INT, OUT p_count INT)
BEGIN
    SELECT COUNT(*)
    INTO p_count
    FROM posts
    WHERE id_u = p_user_id;
END$$

/* 1.4 Запросы в друзья по статусу */
CREATE PROCEDURE sp_friend_requests_by_status(IN p_status INT)
BEGIN
    SELECT *
    FROM friends_requests
    WHERE id_s = p_status;
END$$

/* 1.5 Локальные переменные */
CREATE PROCEDURE sp_users_summary()
BEGIN
    DECLARE users_cnt INT;
    DECLARE posts_cnt INT;

    SELECT COUNT(*) INTO users_cnt FROM users;
    SELECT COUNT(*) INTO posts_cnt FROM posts;

    SELECT CONCAT('Пользователей: ', users_cnt, ', Постов: ', posts_cnt) AS summary;
END$$

/* 2.1 Условная логика */
CREATE PROCEDURE sp_user_activity(IN p_posts INT)
BEGIN
    SELECT CASE
        WHEN p_posts = 0 THEN 'Неактивный'
        WHEN p_posts BETWEEN 1 AND 2 THEN 'Средняя активность'
        ELSE 'Активный'
    END AS activity_level;
END$$

/* 2.2 Цикл */
CREATE PROCEDURE sp_even_user_ids(IN p_limit INT)
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE result TEXT DEFAULT '';

    WHILE i <= p_limit DO
        IF i % 2 = 0 THEN
            SET result = CONCAT(result, i, ' ');
        END IF;
        SET i = i + 1;
    END WHILE;

    SELECT result AS even_ids;
END$$

/* 2.3 Транзакция */
CREATE PROCEDURE sp_add_friend(IN p_user1 INT, IN p_user2 INT)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SELECT 'Ошибка, транзакция отменена' AS result;
    END;

    START TRANSACTION;

    INSERT INTO friends (id_friend_one, id_friend_two)
    VALUES (p_user1, p_user2);

    COMMIT;
    SELECT 'Друг добавлен' AS result;
END$$

/* 2.4 Обработка ошибок */
CREATE PROCEDURE sp_safe_divide(IN a INT, IN b INT)
BEGIN
    IF b = 0 THEN
        SELECT 'Ошибка: деление на ноль' AS error;
    ELSE
        SELECT a / b AS result;
    END IF;
END$$

/* 2.5 Процедура вызывает другую */
CREATE PROCEDURE sp_user_activity_check(IN p_user_id INT)
BEGIN
    DECLARE cnt INT;

    CALL sp_user_posts_count(p_user_id, cnt);
    CALL sp_user_activity(cnt);
END$$

/* 3.1 Динамический SQL */
CREATE PROCEDURE sp_dynamic_users_sort(IN p_field VARCHAR(20))
BEGIN
    IF p_field NOT IN ('name', 'email') THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Недопустимое поле сортировки';
    END IF;

    SET @sql = CONCAT('SELECT * FROM users ORDER BY ', p_field);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END$$

/* 3.2 Курсор */
CREATE PROCEDURE sp_update_user_numbers()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE uid INT;

    DECLARE cur CURSOR FOR SELECT id_u FROM users;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    OPEN cur;

    read_loop: LOOP
        FETCH cur INTO uid;
        IF done THEN LEAVE read_loop; END IF;

        UPDATE users SET number_p = (
            SELECT COUNT(*) FROM posts WHERE id_u = uid
        ) WHERE id_u = uid;
    END LOOP;

    CLOSE cur;
END$$

/* 3.3 Возврат набора данных */
CREATE PROCEDURE sp_groups_members()
BEGIN
    SELECT g.name, COUNT(mg.id_m) AS members_count
    FROM groups g
    LEFT JOIN members_groups mg ON g.id_g = mg.id_g
    GROUP BY g.name;
END$$

/* 3.4 Бизнес-логика */
CREATE PROCEDURE sp_accept_friend_request(IN p_request_id INT)
BEGIN
    START TRANSACTION;

    INSERT INTO friends (id_friend_one, id_friend_two)
    SELECT id_friend_one, id_friend_two FROM friends_requests WHERE id_f_r = p_request_id;

    UPDATE friends_requests SET id_s = 2 WHERE id_f_r = p_request_id;

    COMMIT;
END$$

/* 3.5 CTE */
CREATE PROCEDURE sp_user_posts_rank()
BEGIN
    WITH stats AS (
        SELECT id_u, COUNT(*) AS cnt FROM posts GROUP BY id_u
    )
    SELECT u.name, s.cnt
    FROM stats s
    JOIN users u ON u.id_u = s.id_u
    ORDER BY s.cnt DESC;
END$$

DELIMITER ;
